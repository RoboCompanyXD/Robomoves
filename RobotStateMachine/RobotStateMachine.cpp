/**
 * File:   UC.cpp
 * Author: chris
 *
 * Created on 30 de junio de 2020, 10:52
 */

#include "RobotStateMachine.h"
#include "../ControlRobot/ControlRobot.h"
#include <stdexcept>

/**
 * RobotStateMachine Class constructor
 * @param cr Pointer to an instance of this system's robot controller interface.
 */
RobotStateMachine::RobotStateMachine(ControlRobot::ControlRobot * cr) {
    this->robot = cr;
    initStatechart();
}

/**
 * RobotStateMachine Class destructor
 */
RobotStateMachine::~RobotStateMachine() {
    // TODO
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::initStatechart() {
    currentSuperState = DISABLED; // TODO: change to UC_Enum.OMNonState for better readability
    currentState = DISABLED;
    currentUnDock_subState = DISABLED;
    currentNormalOperate_subState = DISABLED;
    currentTrackingByCamera_subState = DISABLED;
    currentPersonOutView_subState = DISABLED;
    currentPersonInView_subState = DISABLED;
    PersonInView_timeout = 0; // TODO: BORRAR?
    currentDodgeObstacle_subState = DISABLED;
    currentCrashAlgorithm_subState = DISABLED;
    currentCliffAhead_subState = DISABLED;
    rootState_entDef();
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::rootState_entDef() {
    currentSuperState = IDLE;
    currentState = IDLE;
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::UnDock_entDef() {
    currentSuperState = UN_DOCKING;
    //#[ transition UnDock.0 
    robot->sensores.sum_distance = 0;
    //#]
    currentUnDock_subState = ExitDock;
    currentState = ExitDock;
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::NormalOperate_entDef() {
    currentSuperState = NORMAL_ROAMING;
    NormalOperateEntDef();
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::NormalOperateEntDef() {
    TrackingByCamera_entDef();
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::TrackingByCamera_entDef() {
    currentNormalOperate_subState = TrackingByCamera;
    TrackingByCameraEntDef();
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::TrackingByCameraEntDef() {
    //## transition 14 
    if (robot->cam.isPersonInView == true) {
        PersonInView_entDef();
    } else {
        PersonOutView_entDef();
    }
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::PersonInView_entDef() {
    currentTrackingByCamera_subState = PersonInView;
    currentPersonInView_subState = PersonInView_ApproachUser;
    currentState = PersonInView_ApproachUser;
    //#[ state NormalOperate.TrackingByCamera.PersonInView.PersonInView.PersonInView_ApproachUser.(Entry) 
    robot->computeCameraApproach();
    //#]
    //PersonInView_timeout = scheduleTimeout(ComputeStepTime, "ROOT.NormalOperate.TrackingByCamera.PersonInView.ROOT.PersonInView.PersonInView_ApproachUser");
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::PersonOutView_entDef() {
    currentTrackingByCamera_subState = PersonOutView;
    //#[ transition NormalOperate.TrackingByCamera.PersonOutView.4 
    robot->sensores.sum_angle = 0;
    robot->sensores.sum_distance = 0;
    //#]
    currentPersonOutView_subState = PersonOutView_Rotate360;
    currentState = PersonOutView_Rotate360;
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::DodgeObstacle_entDef() {
    currentNormalOperate_subState = DodgeObstacle;
    //#[ transition 9 
    robot->sensores.sum_angle = 0;
    robot->sensores.sum_distance = 0;
    //#]
    currentDodgeObstacle_subState = Dodge_MoveBack;
    currentState = Dodge_MoveBack;
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::CliffAhead_entDef() {
    currentNormalOperate_subState = CliffAhead;
    //#[ transition 12 
    robot->sensores.sum_angle = 0;
    robot->sensores.sum_distance = 0;
    //#]
    currentCliffAhead_subState = CliffAhead_Rotate180;
    currentState = CliffAhead_Rotate180;
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::CrashAlgorithm_entDef() {
    currentDodgeObstacle_subState = CrashAlgorithm;
    currentCrashAlgorithm_subState = CrashAlgorithm_Dodge;
    currentState = CrashAlgorithm_Dodge;
}

/**
 * Partly auto-generated by Rhapsody
 * 
 * This method handles the flow of the state machine.
 * 
 * 
 * TODO: documentar
 */
void RobotStateMachine::statechart_process() {

    /**
     * First level "super-case" machine states: 
     *  - Idle
     *  - Dock
     *  - Shutdown
     *  - Undock
     *  - Normal Operate
     */
    switch (currentState) {

        case IDLE:
        {
            /**
             * IDLE super-state
             * Description: The robot is motionless (motors are off), but sensor data is still being checked.
             * Enter-conditions:
             *  - While in Initializing     >> Successful system initialization
             *  - While in NORMAL_ROAMING   >> 'Clean' button is pressed
             *  - While in DOCKING          >> the robot has finished docking in the charge-bay
             * Exit-conditions:
             *  - 'Spot' button is pressed  >> go to SHUTDOWN
             *  - 'Dock' button is pressed  >> go to DOCKING
             *  - 'Clean' button is pressed >> if inDock == true  >> go to NORMAL_ROAMING 
             *  - 'Clean' button is pressed >> if inDock == false >> go to UN_DOCKING
             */

            if (robot->sensores.battery_level < 15 || robot->check_btnDock()) {
                currentSuperState = DOCKING;
                currentState = DOCKING;
                //#[ state Dock.(Entry) 
                robot->gotoDock();
                //#]
                break; // exit from Idle super-state
            } else if (robot->check_btnClean()) {
                if (robot->sensores.IsDocked == true) {
                    UnDock_entDef();
                    break; // Salir inmediatamente del sub-estado
                } else {
                    // TODO: CRITICAL Why do we enter into NormalOperate by default here???
                    //       If battery > 15 && !DockButton && !CleanButton then entDef NormalOperate
                    NormalOperate_entDef();
                    break; // Salir inmediatamente del sub-estado
                }
            } else if (robot->check_btnSpot()) {
                currentSuperState = SHUTDOWN;
                currentState = SHUTDOWN;
                break; // Salir inmediatamente del sub-estado
            }

            break; // exit super-case IDLE
        } //end case IDLE

        case DOCKING:
        {
            /**
             * DOCKING super-state
             * 
             * Description: the robot is going to the charge-bay
             * Enter-conditions:
             *  - While in IDLE or NORMAL_ROAMING >> 'Dock' button is pressed
             *  - While in IDLE or NORMAL_ROAMING >> battery_level < 15% is detected
             * Exit-conditions:
             *  - inDock == true is detected      >> go to IDLE
             */
            if (robot->sensores.IsDocked == true) {
                currentSuperState = IDLE;
                currentState = IDLE;
                break; // Salir inmediatamente del sub-estado DOCKING
            }

            // TODO CRITICAL: why is this state empty???? There is no action taken in this state
            //                Should not we be calling goToDock() to compute the dock???

            break; // exit super-case DOCKING
        } // end case DOCKING

        case SHUTDOWN:
        {
            /**
             *  SHUTDOWN super-state
             * Description: Fin de operacion. Terminar la ejecucion del algoritmo principal, liberar recursos y salir.
             * Enter-conditions:
             *  - While in Initializing   >> 'Spot' button is pressed
             *  - While in IDLE           >> 'Spot' button is pressed
             *  - While in NORMAL_ROAMING >> 'Spot' button is pressed
             *  - While in UN_DOCKING     >> 'Spot' button is pressed
             * Exit-conditions:
             *  - All systems shut down.
             */
            currentState = Statechart_End;
            currentSuperState = Statechart_End;
            endBehavior();

            break; // exit case SHUTDOWN
        } // end case SHUTDOWN

        case UN_DOCKING:
        {
            /**
             * UN_DOCKING super-state
             * Description: Exit charging dock and turn around
             * Sub-states:
             *  - ExitDock
             *  - UnDock_Rotate180
             * Enter-conditions:
             *  - While in IDLE            >> 'Clean' button is pressed && inDock == true
             * Exit-conditions:
             *  - 'Spot' button is pressed >> go to SHUTDOWN
             *  - Successful un-docking    >> go to NORMAL_ROAMING
             */

            if (robot->check_btnSpot()) {

                // Desactivar UnDock sub-states

                currentUnDock_subState = DISABLED;
                currentSuperState = SHUTDOWN;
                currentState = SHUTDOWN;

                break; // Exit the UN_DOCKING super-state immediately, without computing UnDock's sub-states
            }

            /**
             * UN_DOCKING sub-states:
             *  - UN_DOCKING->ExitDock
             *  - UN_DOCKING->UnDock_Rotate180
             */
            switch (currentUnDock_subState) {
                case ExitDock:
                {
                    /**
                     * UN_DOCKING->ExitDock sub-state
                     * Description: Step backwards to exit charging dock
                     * Enter-conditions:
                     *  - Default UN_DOCKING sub-state
                     * Exit-conditions:
                     *  - sensoresSumDistancia < -300 is detected >> go to UN_DOCKING->UnDock_Rotate180
                     */

                    robot->setMotores_actual(motores_BACK);
                    //## transition UnDock.1 
                    if (robot->sensores.sum_distance < -300) {
                        //#[ transition UnDock.1 
                        robot->sensores.sum_angle = 0;
                        //#]
                        currentUnDock_subState = UnDock_Rotate180;
                        currentState = UnDock_Rotate180;
                        break; // Salir inmediatamente del sub-estado
                    }

                    break; // end case "ExitDock"
                } // end ExitDock

                case UnDock_Rotate180:
                {
                    /**
                     * UN_DOCKING->UnDock_Rotate180 sub-state
                     * Description: Turn away from charge-bay and face towards the room by rotating 180º
                     * Enter-conditions:
                     *  - While in UN_DOCKING->ExitDock >> sensoresSumDistancia < -300 is detected
                     * Exit-conditions:
                     *  - sensoresSumAngulo > 180º is detected >> go to NORMAL_ROAMING
                     */

                    robot->setMotores_actual(motores_LEFT);
                    //## transition UnDock.2 
                    if (robot->sensores.sum_angle > 180) {
                        currentUnDock_subState = DISABLED;
                        NormalOperate_entDef(); // go to NORMAL_ROAMING
                        break; // Salir inmediatamente del sub-estado UnDock >> Rotate180º para entrar en NormalOperate
                    }

                    break; // end case "UnDock_Rotate180"
                } // end UnDock_Rotate180

                default:
                    throw std::logic_error("Invalid 'currentUnDock_subState' " << currentUnDock_subState << " state value within the state-machine");
                    break;
            } // end "UnDock" (second level) sub-states

            break; // exit super-state UN_DOCKING
        } // end case UN_DOCKING

        case NORMAL_ROAMING:
        {
            /**
             * NORMAL_ROAMING super-state
             * Description: Modo de operacion normal.
             * Sub-states:
             *  - TrackingByCamera
             *  - CliffAhead
             *  - DodgeObstacle
             * Enter-conditions:
             *  - While in UN_DOCKING >> Successful un-docking
             *  - While in IDLE       >> 'Clean' button is pressed && inDock == false
             * Exit-conditions:
             *  - 'Spot' button is pressed >> go to SHUTDOWN
             *  - 'Dock' button is pressed >> go to DOCKING
             */

            // TODO: Resumir Qué se hace en los siguientes if-else:
            if (robot->sensores.battery_level < 15 || robot->check_btnDock()) {
                //NormalOperate_exit();
                currentSuperState = DOCKING;
                currentState = DOCKING;
                //#[ state Dock.(Entry) 
                robot->gotoDock();
                //#]
                break; // Salir inmediatamente del sub-estado
            } else if (robot->check_btnClean()) {
                //NormalOperate_exit();
                currentSuperState = IDLE;
                currentState = IDLE;
                break; // Salir inmediatamente del sub-estado
            } else if (robot->check_btnSpot()) {
                //NormalOperate_exit();
                currentSuperState = SHUTDOWN;
                currentState = SHUTDOWN;
                break; // Salir inmediatamente del sub-estado
            }


            /**
             * NORMAL_ROAMING sub-states (second level):
             *  - NORMAL_ROAMING->TrackingByCamera
             *  - NORMAL_ROAMING->Cliff Ahead
             *  - NORMAL_ROAMING->DodgeObstacle
             */
            switch (currentNormalOperate_subState) {
                    // State TrackingByCamera
                    // Description: Seguimiento mediante la camara.
                case TrackingByCamera:
                {
                    /**
                     * NORMAL_ROAMING->TrackingByCamera sub-state
                     * Description: The robot is trying to follow the user using the RGB camera.
                     * Sub-states:
                     *  - NORMAL_ROAMING->TrackingByCamera->PersonOutView
                     *  - NORMAL_ROAMING->TrackingByCamera->PersonInView
                     * Enter-conditions:
                     *  - Default NORMAL_ROAMING sub-state
                     *  - While in NORMAL_ROAMING->CliffAhead->GoForward          >> sensoresSumDistancia > 300 is detected
                     *  - While in NORMAL_ROAMING->DodgleObstacle->CrashAlgorithm >> Finished 
                     * Exit-conditions:
                     *  - sensoresCliff == true is detected >> go to NORMAL_ROAMING->CliffAhead
                     *  - sensoresBl OR sensoresBr == true is detected >> go to NORMAL_ROAMING->DodgeObstacle
                     */

                    // TODO: Resumir Qué se hace en los siguientes if-else:
                    if (robot->sensores.bl == true || robot->sensores.br == true) {
                        currentTrackingByCamera_subState = DISABLED;
                        currentPersonInView_subState = DISABLED;
                        currentPersonOutView_subState = DISABLED;
                        DodgeObstacle_entDef();
                        break; // Salir inmediatamente del sub-estado
                    } else if (robot->sensores.cliff == true) {
                        currentTrackingByCamera_subState = DISABLED;
                        currentPersonInView_subState = DISABLED;
                        currentPersonOutView_subState = DISABLED;
                        CliffAhead_entDef();

                    }

                    /**
                     * NORMAL_ROAMING->TrackingByCamera sub-sub-states (third level):
                     *  - NORMAL_ROAMING->TrackingByCamera->PersonInView
                     *  - NORMAL_ROAMING->TrackingByCamera->PersonOutView
                     */
                    switch (currentTrackingByCamera_subState) {
                        case PersonInView:
                        {
                            /**
                             * NORMAL_ROAMING->TrackingByCamera->PersonInView sub-sub-state
                             * Description: the user is within the RGB camera's line-of-view
                             * Sub-states:
                             *  - ApproachUser
                             *  - PathBlocked
                             * Enter-conditions:
                             *  - When first entering NORMAL_ROAMING->TrackingByCamera     >> cameraIsPersonInView == true is detected
                             *  - While in NORMAL_ROAMING->TrackingByCamera->PersonOutView >> cameraIsPersonInView == true is detected
                             * Exit-conditions:
                             *  - cameraIsPersonInView == false is detected >> go to NORMAL_ROAMING->TrackingByCamera->PersonOutView
                             */

                            // Description: La persona está a la vista.
                            // Acercarse todo lo que se pueda sin invadir su espacio.

                            if (robot->cam.isPersonInView == false) {
                                currentPersonInView_subState = DISABLED;
                                PersonOutView_entDef();
                                break; // Salir inmediatamente del sub-estado
                            }

                            /**
                             * NORMAL_ROAMING->TrackingByCamera->PersonInView->PersonInView sub-sub-sub-states (fourth level):
                             *  - NORMAL_ROAMING->TrackingByCamera->PersonInView->ApproachUser
                             *  - NORMAL_ROAMING->TrackingByCamera->PersonInView->PathBlocked
                             */
                            switch (currentPersonInView_subState) {
                                case PersonInView_ApproachUser:
                                {
                                    /**
                                     * NORMAL_ROAMING->TrackingByCamera->PersonInView->ApproachUser sub-sub-sub-state
                                     * Description: approach the user (get as close to the user as possible if there is no obstacles ahead)
                                     * Enter-conditions:
                                     *  - When entering NORMAL_ROAMING->TrackingByCamera->PersonInView         >> by default
                                     *  - While in NORMAL_ROAMING->TrackingByCamera->PersonInView->PathBlocked >> lidarIsObstacle == false is detected
                                     * Exit-conditions:
                                     *  - Handled by NORMAL_ROAMING->TrackingByCamera sub-state
                                     */

                                    robot->computeCameraApproach();
                                    if (robot->lidar.isObstable == true) {
                                        //#[ transition NormalOperate.TrackingByCamera.PersonInView.1 
                                        robot->reproducirSonidoBloqueado();
                                        //#]
                                        currentPersonInView_subState = PersonInView_PathBlocked;
                                        currentState = PersonInView_PathBlocked;
                                        //#[ state NormalOperate.TrackingByCamera.PersonInView.PersonInView.PersonInView_PathBlocked.(Entry) 
                                        //#]
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case "PersonInView_ApproachUser"
                                } // end ApproachUser

                                    // State PersonInView_PathBlocked
                                    // Description: Obstaculo en el camino
                                    // El obstaculo puede ser una persona o un onstaculo real
                                    // Puedo rotar si la persona se mueve y retroceder
                                case PersonInView_PathBlocked:
                                {
                                    // Ejecutar funcion de calculo de aproximacion con obstaculo
                                    robot->computeCameraWithObstacle();
                                    if (robot->lidar.isObstable == false) {
                                        //#[ transition NormalOperate.TrackingByCamera.PersonInView.1 
                                        robot->reproducirSonidoDesbloqueado();
                                        //#]
                                        currentPersonInView_subState = PersonInView_ApproachUser;
                                        currentState = PersonInView_ApproachUser;
                                        //#[ state NormalOperate.TrackingByCamera.PersonInView.PersonInView.PersonInView_Pathblocked.(Entry) 
                                        //#]
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case "PersonInView_Pathblocked"
                                } // end PathLocked

                                default:
                                    throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                                    break;
                            } // end switch "PersonInView_subState"
                            break; // end case "PersonInView"
                        } // end "PersonInView"

                        case PersonOutView:
                        {
                            // State PersonOutView
                            // Description: La persona no está a la vista.
                            // Ejecutar algoritmo de búsqueda.

                            /**
                             * "Person out of view" sub-sub-sub-states (fourth level):
                             *  - Rotate to move
                             *  - Compute position
                             *  - Go forward
                             *  - Rotate 360º
                             */
                            switch (currentPersonOutView_subState) {
                                case PersonOutView_RotateToMove:
                                {
                                    // State PersonOutView_RotateToMove
                                    robot->setMotores_actual(motores_LEFT);
                                    if (robot->sensores.sum_angle > robot->lidar.computedAngle) {
                                        currentPersonOutView_subState = PersonOutView_GoForward;
                                        currentState = PersonOutView_GoForward;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case "PersonOutView_RotateToMove"
                                } // end PersonOutView_RotateToMove

                                case PersonOutView_ComputePosition:
                                {
                                    // State PersonOutView_ComputePosition
                                    // Description: Computar posicion a la que dirigirse.
                                    // Encontrar sector con mayor media de distancia.

                                    // Calcular la posicion a la que dirigirse
                                    //#[ transition NormalOperate.TrackingByCamera.PersonOutView.0 
                                    robot->sensores.sum_angle = 0;
                                    robot->lidar.computeLidarTripPersonOutOfView();
                                    //#]
                                    currentPersonOutView_subState = PersonOutView_RotateToMove;
                                    currentState = PersonOutView_RotateToMove;

                                    break; // end case "PersonOutView_ComputePosition"
                                } // end PersonOutView_ComputePosition

                                case PersonOutView_GoForward:
                                {
                                    // State PersonOutView_GoForward
                                    robot->setMotores_actual(motores_FWD);
                                    // TODO: resumir lo que se hace en este if
                                    if (robot->sensores.sum_distance > robot->lidar.computedDistance) {
                                        //#[ transition NormalOperate.TrackingByCamera.PersonOutView.2 
                                        robot->sensores.sum_angle = 0;
                                        //#]
                                        currentPersonOutView_subState = PersonOutView_Rotate360;
                                        currentState = PersonOutView_Rotate360;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case "PersonOutView_GoForward"
                                } // end PersonOutView_GoForward

                                case PersonOutView_Rotate360:
                                {
                                    // State PersonOutView_Rotate360
                                    robot->setMotores_actual(motores_LEFT);
                                    // TODO: resumir lo que se hace dentro de este if
                                    if (robot->sensores.sum_angle > 360) {
                                        currentPersonOutView_subState = PersonOutView_ComputePosition;
                                        currentState = PersonOutView_ComputePosition;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case "PersonOutView_GoForward"
                                } // end PersonOutView_GoForward

                                default:
                                    throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                                    break;
                            } //end switch (PersonOutView_subState)

                            break; // end case PersonOutView
                        } //end PersonOutView

                        default:
                            throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                            break;
                    } // end switch (TrackingByCamera_subState)

                    break; // end case "TrackingByCamera"
                } // end TrackingByCamera

                case DodgeObstacle:
                {
                    // State NormalOperate >> DodgeObstacle
                    // Description: Se ha colisionado con un obstaculo.
                    // Rodear el obstaculo y volver a encontrar a la persona.

                    if (robot->sensores.cliff == true) {
                        currentCrashAlgorithm_subState = DISABLED;
                        currentDodgeObstacle_subState = DISABLED;
                        CliffAhead_entDef();
                        break; // Salir inmediatamente del sub-estado
                    }

                    /**
                     * "Dodge Obstacle" sub-sub-states (third level):
                     *  - Move back
                     *  - Crash algorithm
                     */
                    switch (currentDodgeObstacle_subState) { // State Dodge_MoveBack
                        case Dodge_MoveBack:
                        {
                            // State NormalOperate >> DodgeObstacle >> MoveBack
                            robot->setMotores_actual(motores_BACK);
                            //## transition 10 
                            if (robot->sensores.sum_distance < -30) {
                                CrashAlgorithm_entDef();
                                break; // Salir inmediatamente del sub-estado
                            }

                            break; // end case Dodge_MoveBack
                        } // end Dodge_MoveBack

                        case CrashAlgorithm:
                        {
                            // State NormalOperate >> DodgeObstacle >> CrashAlgorithm
                            // Description: Algoritmo de rodeo.
                            // (El del TFG)

                            if (robot->sensores.bl == true || robot->sensores.br == true) {
                                currentCrashAlgorithm_subState = DISABLED;
                                //#[ transition 11 
                                robot->sensores.sum_distance = 0;
                                //#]
                                currentDodgeObstacle_subState = Dodge_MoveBack;
                                currentState = Dodge_MoveBack;
                                break; // Salir inmediatamente del sub-estado
                            }

                            /**
                             * "Crash Algorithm" sub-sub-sub-states (fourth level):
                             *  - Dodge
                             *  - Dodge Parallel
                             *  - Go Forward
                             *  - Go Forward Extended
                             *  - Recover Trajectory
                             */
                            switch (currentCrashAlgorithm_subState) {
                                case CrashAlgorithm_Dodge:
                                {
                                    // State NormalOperate >> DodgeObstacle >> CrashAlgorithm >> Dodge
                                    robot->setMotores_actual(motores_LEFT);
                                    if (robot->sensores.sum_angle > 25) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_DodgeParallel;
                                        currentState = CrashAlgorithm_DodgeParallel;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case CrashAlgorithm_Dodge
                                } // end CrashAlgorithm_Dodge

                                case CrashAlgorithm_DodgeParallel:
                                {
                                    // State NormalOperate >> DodgeObstacle >> CrashAlgorithm >> DodgeParallel
                                    robot->setMotores_actual(motores_LEFT);
                                    if (robot->sensores.lbump_front == false) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_GoForward;
                                        currentState = CrashAlgorithm_GoForward;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end CrashAlgorithm_DodgeParallel
                                } // end CrashAlgorithm_DodgeParallel

                                case CrashAlgorithm_GoForward:
                                {
                                    // State NormalOperate >> DodgeObstacle >> CrashAlgorithm >> GoForward
                                    robot->setMotores_actual(motores_FWD);
                                    if (robot->sensores.lbump_side == false) {
                                        //#[ transition NormalOperate.DodgeObstacle.CrashAlgorithm.5 
                                        robot->sensores.sum_distance = 0;
                                        //#]
                                        currentCrashAlgorithm_subState = CrashAlgorithm_GoForwardExtended;
                                        currentState = CrashAlgorithm_GoForwardExtended;
                                        break; // Salir inmediatamente del sub-estado
                                    } else if (robot->sensores.lbump_front == true) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_DodgeParallel;
                                        currentState = CrashAlgorithm_DodgeParallel;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end CrashAlgorithm_GoForward
                                } // end CrashAlgorithm_GoForward

                                case CrashAlgorithm_GoForwardExtended:
                                {
                                    // State CrashAlgorithm_GoForwardExtended
                                    robot->setMotores_actual(motores_FWD);
                                    if (robot->sensores.sum_distance > 300) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_RecoverTrajectory;
                                        currentState = CrashAlgorithm_RecoverTrajectory;
                                        break; // Salir inmediatamente del sub-estado
                                    } else if (robot->sensores.lbump_front == false && robot->sensores.lbump_side == true) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_GoForward;
                                        currentState = CrashAlgorithm_GoForward;
                                        break; // Salir inmediatamente del sub-estado
                                    } else if (robot->sensores.lbump_front == true) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_DodgeParallel;
                                        currentState = CrashAlgorithm_DodgeParallel;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end CrashAlgorithm_GoForwardExtended
                                } // end CrashAlgorithm_GoForwardExtended

                                case CrashAlgorithm_RecoverTrajectory:
                                {
                                    // State CrashAlgorithm_RecoverTrajectory
                                    robot->setMotores_actual(motores_RIGHT);
                                    if (robot->sensores.sum_angle > -25 && robot->sensores.sum_angle < 25) {
                                        currentDodgeObstacle_subState = DISABLED;
                                        TrackingByCamera_entDef();
                                        break; // Salir inmediatamente del sub-estado
                                    } else if (robot->sensores.lbump_front == true) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_DodgeParallel;
                                        break; // Salir inmediatamente del sub-estado
                                        currentState = CrashAlgorithm_DodgeParallel;
                                    } else if (robot->sensores.lbump_front == false && robot->sensores.lbump_side == true) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_GoForward;
                                        currentState = CrashAlgorithm_GoForward;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case CrashAlgorithm_RecoverTrajectory
                                } // end CrashAlgorithm_RecoverTrajectory

                                default:
                                    throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                                    break;

                            } // end switch (CrashAlgorithm_subState)

                            break; // end case CrashAlgorithm:
                        } // end CrashAlgorithm:

                        default:
                            throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                            break;
                    } // end switch DodgeObstacle_subState

                    break; // end case DodgeObstacle
                }// end DodgeObstacle

                case CliffAhead:
                {
                    // State CliffAhead
                    // Description: Barranco detectado.
                    // Devolver el robot a un estado seguro.

                    /**
                     * "Cliff Ahead" sub-states:
                     *  - Rotate 180º
                     *  - Go Forward
                     */
                    switch (currentCliffAhead_subState) {
                        case CliffAhead_Rotate180:
                        {
                            // State CliffAhead_Rotate180
                            if (robot->sensores.sum_angle > 180) {
                                currentCliffAhead_subState = CliffAhead_GoForward;
                                currentState = CliffAhead_GoForward;
                                break; // Salir inmediatamente del sub-estado
                            }

                            break; // end CliffAhead_Rotate180
                        } // end CliffAhead_Rotate180

                        case CliffAhead_GoForward:
                        {
                            // State CliffAhead_GoForward
                            if (robot->sensores.sum_distance > 300) {
                                currentCliffAhead_subState = DISABLED;
                                TrackingByCamera_entDef();
                                break; // Salir inmediatamente del sub-estado
                            }

                            break; // end CliffAhead_GoForward
                        } // end CliffAhead_GoForward

                        default:
                            throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                            break;

                    } // end switch (CliffAhead_subState)

                    break; // end case CliffAhead
                }

                default:
                    throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                    break;

            } //end switch (NormalOperate_subState)

            break; // end case "NormalOperate"
        } // end NormalOperate

        default:
            throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
            break;

    } // end TOP-level switch (rootState_active)

} // end void UC::statechart_process()

/**
 * TODO: documentar
 */
void RobotStateMachine::endBehavior() {

}