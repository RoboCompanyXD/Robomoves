/**
 * File:   UC.cpp
 * Author: chris
 *
 * Created on 30 de junio de 2020, 10:52
 */

#include "RobotStateMachine.h"
#include "../ControlRobot/ControlRobot.h"
#include <stdexcept>

/**
 * RobotStateMachine Class constructor
 * @param cr Pointer to an instance of this system's robot controller interface.
 */
RobotStateMachine::RobotStateMachine(ControlRobot::ControlRobot * cr) {
    this->robot = cr;
    initStatechart();
}

/**
 * RobotStateMachine Class destructor
 */
RobotStateMachine::~RobotStateMachine() {
    // TODO
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::initStatechart() {
    currentSuperState = DISABLED; // TODO: change to UC_Enum.OMNonState for better readability
    currentState = DISABLED;
    currentUnDocking_subState = DISABLED;
    currentRoaming_subState = DISABLED;
    currentTrackingByCamera_subState = DISABLED;
    currentSearchingUser_subState = DISABLED;
    currentFollowingUser_subState = DISABLED;
    currentDodgingObstacle_subState = DISABLED;
    currentCrashAlgorithm_subState = DISABLED;
    currentAvoidingCliff_subState = DISABLED;
    rootState_entDef();
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::rootState_entDef() {
    currentSuperState = IDLE;
    currentState = IDLE;
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::UnDock_entDef() {
    currentSuperState = UN_DOCKING;
    robot->sensores.sum_distance = 0;
    currentUnDocking_subState = ExitDock;
    currentState = ExitDock;
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::roaming_entDef() {
    currentSuperState = ROAMING;
    RoamingEntDef();
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::RoamingEntDef() {
    TrackingByCamera_entDef();
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::TrackingByCamera_entDef() {
    currentRoaming_subState = TrackingByCamera;
    TrackingByCameraEntDef();
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::TrackingByCameraEntDef() {
    if (robot->cam->isUserInView == true) {
        followingUser_entDef();
    } else {
        searchingUser_entDef();
    }
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::followingUser_entDef() {
    currentTrackingByCamera_subState = FollowingUser;
    currentFollowingUser_subState = FollowingUser_GettingCloser;
    currentState = FollowingUser_GettingCloser;
    robot->computeCameraApproach();
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::searchingUser_entDef() {
    currentTrackingByCamera_subState = SearchingUser;
    robot->sensores.sum_angle = 0;
    robot->sensores.sum_distance = 0;
    currentSearchingUser_subState = SearchingUser_Look360Around;
    currentState = SearchingUser_Look360Around;
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::dodgingObstacle_entDef() {
    currentRoaming_subState = DodgingObstacle;
    robot->sensores.sum_angle = 0;
    robot->sensores.sum_distance = 0;
    currentDodgingObstacle_subState = MovingBackFromObstacle;
    currentState = MovingBackFromObstacle;
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::avoidingCliff_entDef() {
    currentRoaming_subState = AvoidingCliff;
    robot->sensores.sum_angle = 0;
    robot->sensores.sum_distance = 0;
    currentAvoidingCliff_subState = TurnAwayFromCliff;
    currentState = TurnAwayFromCliff;
}

/**
 * Auto-generated by Rhapsody
 * TODO: documentar
 */
void RobotStateMachine::CrashAlgorithm_entDef() {
    currentDodgingObstacle_subState = CrashAlgorithm;
    currentCrashAlgorithm_subState = CrashAlgorithm_Dodge;
    currentState = CrashAlgorithm_Dodge;
}

/**
 * Partly auto-generated by Rhapsody
 * 
 * This method handles the flow of the state machine.
 * 
 * 
 * TODO: documentar
 */
void RobotStateMachine::statechart_process() {

    /**
     * First level "super-case" machine states: 
     *  - Idle
     *  - Dock
     *  - Shutdown
     *  - Undock
     *  - Normal Operate
     */
    switch (currentState) {

        case IDLE:
        {
            /**
             * IDLE super-state
             * Description: The robot is motionless (motors are off), but sensor data is still being checked.
             * Enter-conditions:
             *  - When powering ON robot    >> by default
             *  - While in NORMAL_ROAMING   >> 'Clean' button is pressed
             *  - While in DOCKING          >> the robot has finished docking in the charge-bay
             * Exit-conditions:
             *  - 'Spot' button is pressed  >> go to SHUTDOWN
             *  - 'Dock' button is pressed  >> go to DOCKING
             *  - Battery-level below 15%   >> go to DOCKING
             *  - 'Clean' button is pressed >> if inDock == false >> go to UN_DOCKING
             *  - 'Clean' button is pressed >> if inDock == true  >> go to NORMAL_ROAMING 
             */

            if (robot->sensores.battery_level < 15 || robot->check_btnDock()) {
                currentSuperState = DOCKING;
                currentState = DOCKING;
                robot->gotoDock();
                break; // exit from Idle super-state
            } else if (robot->check_btnClean()) {
                if (robot->sensores.IsDocked == true) {
                    UnDock_entDef();
                    break; // Salir inmediatamente del sub-estado
                } else {
                    // TODO: CRITICAL Why do we enter into NORMAL_ROAMING by default here???
                    //       If battery > 15 && !DockButton && !CleanButton then entDef NormalOperate
                    roaming_entDef();
                    break; // Salir inmediatamente del sub-estado
                }
            } else if (robot->check_btnSpot()) {
                currentSuperState = SHUTDOWN;
                currentState = SHUTDOWN;
                break; // Salir inmediatamente del sub-estado
            }

            break; // exit super-case IDLE
        } //end case IDLE

        case DOCKING:
        {
            /**
             * DOCKING super-state
             * 
             * Description: the robot is going to the charge-bay
             * Enter-conditions:
             *  - While in IDLE or NORMAL_ROAMING >> 'Dock' button is pressed
             *  - While in IDLE or NORMAL_ROAMING >> battery_level < 15% is detected
             * Exit-conditions:
             *  - inDock == true is detected      >> go to IDLE
             */
            if (robot->sensores.IsDocked == true) {
                currentSuperState = IDLE;
                currentState = IDLE;
                break; // Salir inmediatamente del sub-estado DOCKING
            }

            // TODO CRITICAL: why is this state empty???? There is no action taken in this state
            //                Should not we be calling goToDock() to compute the dock???

            break; // exit super-case DOCKING
        } // end case DOCKING

        case SHUTDOWN:
        {
            /**
             *  SHUTDOWN super-state
             * Description: Fin de operacion. Terminar la ejecucion del algoritmo principal, liberar recursos y salir.
             * Enter-conditions:
             *  - While in IDLE           >> 'Spot' button is pressed
             *  - While in NORMAL_ROAMING >> 'Spot' button is pressed
             *  - While in UN_DOCKING     >> 'Spot' button is pressed
             * Exit-conditions:
             *  - All systems shut down.
             */
            currentState = END_STATE_MACHINE;
            currentSuperState = END_STATE_MACHINE;
            endBehavior();

            break; // exit case SHUTDOWN
        } // end case SHUTDOWN

        case UN_DOCKING:
        {
            /**
             * UN_DOCKING super-state
             * Description: Exit charging dock and turn around
             * Sub-states:
             *  - ExitDock
             *  - TurnAwayFromDock
             * Enter-conditions:
             *  - While in IDLE            >> 'Clean' button is pressed && inDock == true
             * Exit-conditions:
             *  - 'Spot' button is pressed >> go to SHUTDOWN
             *  - Successful un-docking    >> go to NORMAL_ROAMING
             */

            /** Check exit-condition: if 'Spot' button is pressed >> go to SHUTDOWN */
            if (robot->check_btnSpot()) {
                currentUnDocking_subState = DISABLED;
                currentSuperState = SHUTDOWN;
                currentState = SHUTDOWN;
                break; // Exit the UN_DOCKING super-state immediately, without computing UN_DOCKING's sub-states
            }

            /**
             * UN_DOCKING sub-states:
             *  - UN_DOCKING->ExitDock
             *  - UN_DOCKING->TurnAwayFromDock
             */
            switch (currentUnDocking_subState) {
                case ExitDock:
                {
                    /**
                     * UN_DOCKING->ExitDock sub-state
                     * Description: Step backwards to exit charging dock
                     * Enter-conditions:
                     *  - Default UN_DOCKING sub-state
                     * Exit-conditions:
                     *  - sensoresSumDistancia < -300 is detected >> go to UN_DOCKING->TurnAwayFromDock
                     */

                    /** In this state: set wheels to travel backwards */
                    robot->setMotores_actual(motores_BACK);
                    
                    /** Check exit condition: after moving (backwards) 30cm >> go to Rotate180 */
                    if (robot->sensores.sum_distance < -300) {
                        robot->sensores.sum_angle = 0;
                        currentUnDocking_subState = TurnAwayFromDock;
                        currentState = TurnAwayFromDock;
                        break; // Exit the ExitDock sub-state immediately
                    }

                    break; // end case "ExitDock"
                } // end ExitDock

                case TurnAwayFromDock:
                {
                    /**
                     * UN_DOCKING->TurnAwayFromDock sub-state
                     * Description: Turn away from charge-bay and face towards the room by rotating 180º
                     * Enter-conditions:
                     *  - While in UN_DOCKING->ExitDock >> sensoresSumDistancia < -300 is detected
                     * Exit-conditions:
                     *  - sensoresSumAngulo > 180º is detected >> go to NORMAL_ROAMING
                     */

                    /** In this state: turn around 180º*/
                    robot->setMotores_actual(motores_LEFT);
                    
                    /** Check exit condition: after turning 180º >> go to NORMAL_ROAMING */
                    if (robot->sensores.sum_angle > 180) {
                        currentUnDocking_subState = DISABLED;
                        roaming_entDef(); // go to NORMAL_ROAMING
                        break; // exit immediately from TurnAwayFromDock
                    }

                    break; // exit case "TurnAwayFromDock"
                } // end TurnAwayFromDock

                default:
                    //throw std::logic_error("Invalid 'currentUnDock_subState' " << currentUnDocking_subState << " state value within the state-machine");
                    throw std::logic_error("Invalid 'currentUnDock_subState' state value within the state-machine");
                    break;
            } // end "UN_DOCKING" (second level) sub-states

            break; // exit super-state UN_DOCKING
        } // end case UN_DOCKING

        case ROAMING:
        {
            /**
             * NORMAL_ROAMING super-state
             * Description: Modo de operacion normal.
             * Sub-states:
             *  - TrackingByCamera
             *  - CliffAhead
             *  - DodgingObstacle
             * Enter-conditions:
             *  - While in UN_DOCKING >> Successful un-docking
             *  - While in IDLE       >> 'Clean' button is pressed && inDock == false
             * Exit-conditions:
             *  - 'Spot' button is pressed  >> go to SHUTDOWN
             *  - 'Dock' button is pressed  >> go to DOCKING
             *  - Battery-level below 15%   >> go to DOCKING
             *  - 'Clean' button is pressed >> go to IDE
             */

            /** Check exit conditions: if battery-level < 15% OR 'Dock' button is pressed >> go to DOCKING */
            if (robot->sensores.battery_level < 15 || robot->check_btnDock()) {
                //NormalOperate_exit();
                currentSuperState = DOCKING;
                currentState = DOCKING;
                robot->gotoDock();
                break; // exit from NORMAL_ROAMING immediately
            } else if (robot->check_btnClean()) {
                //NormalOperate_exit();
                currentSuperState = IDLE;
                currentState = IDLE;
                break; // exit from NORMAL_ROAMING immediately
            } else if (robot->check_btnSpot()) {
                //NormalOperate_exit();
                currentSuperState = SHUTDOWN;
                currentState = SHUTDOWN;
                break; // exit from NORMAL_ROAMING immediately
            }

            /**
             * NORMAL_ROAMING sub-states (second level):
             *  - NORMAL_ROAMING->TrackingByCamera
             *  - NORMAL_ROAMING->Cliff Ahead
             *  - NORMAL_ROAMING->DodgingObstacle
             */
            switch (currentRoaming_subState) {
                    // State TrackingByCamera
                    // Description: Seguimiento mediante la camara.
                case TrackingByCamera:
                {
                    /**
                     * NORMAL_ROAMING->TrackingByCamera sub-state
                     * Description: The robot is trying to follow the user using the RGB camera.
                     * Sub-states:
                     *  - NORMAL_ROAMING->TrackingByCamera->SearchingUser
                     *  - NORMAL_ROAMING->TrackingByCamera->FollowingUser
                     * Enter-conditions:
                     *  - Default NORMAL_ROAMING sub-state
                     *  - While in NORMAL_ROAMING->CliffAhead->LeaveCliffBehind          >> sensoresSumDistancia > 300 is detected
                     *  - While in NORMAL_ROAMING->DodgleObstacle->CrashAlgorithm >> Finished 
                     * Exit-conditions:
                     *  - sensoresCliff == true is detected >> go to NORMAL_ROAMING->CliffAhead
                     *  - sensoresBl OR sensoresBr == true is detected >> go to NORMAL_ROAMING->DodgingObstacle
                     */

                    // TODO: Resumir Qué se hace en los siguientes if-else:
                    if (robot->sensores.bl == true || robot->sensores.br == true) {
                        currentTrackingByCamera_subState = DISABLED;
                        currentFollowingUser_subState = DISABLED;
                        currentSearchingUser_subState = DISABLED;
                        dodgingObstacle_entDef();
                        break; // Salir inmediatamente del sub-estado
                    } else if (robot->sensores.cliff == true) {
                        currentTrackingByCamera_subState = DISABLED;
                        currentFollowingUser_subState = DISABLED;
                        currentSearchingUser_subState = DISABLED;
                        avoidingCliff_entDef();

                    }

                    /**
                     * NORMAL_ROAMING->TrackingByCamera sub-sub-states (third level):
                     *  - NORMAL_ROAMING->TrackingByCamera->FollowingUser
                     *  - NORMAL_ROAMING->TrackingByCamera->SearchingUser
                     */
                    switch (currentTrackingByCamera_subState) {
                        case FollowingUser:
                        {
                            /**
                             * NORMAL_ROAMING->TrackingByCamera->FollowingUser sub-sub-state
                             * Description: the user is within the RGB camera's line-of-view
                             * Sub-states:
                             *  - ApproachUser
                             *  - PathBlocked
                             * Enter-conditions:
                             *  - When first entering NORMAL_ROAMING->TrackingByCamera     >> cameraIsUserInView == true is detected
                             *  - While in NORMAL_ROAMING->TrackingByCamera->SearchingUser >> cameraIsUserInView == true is detected
                             * Exit-conditions:
                             *  - cameraIsUserInView == false is detected >> go to NORMAL_ROAMING->TrackingByCamera->SearchingUser
                             */

                            // Description: La persona está a la vista.
                            // Acercarse todo lo que se pueda sin invadir su espacio.

                            if (robot->cam->isUserInView == false) {
                                currentFollowingUser_subState = DISABLED;
                                searchingUser_entDef();
                                break; // Salir inmediatamente del sub-estado
                            }

                            /**
                             * NORMAL_ROAMING->TrackingByCamera->FollowingUser sub-sub-sub-states (fourth level):
                             *  - NORMAL_ROAMING->TrackingByCamera->FollowingUser->ApproachUser
                             *  - NORMAL_ROAMING->TrackingByCamera->FollowingUser->PathBlocked
                             */
                            switch (currentFollowingUser_subState) {
                                case FollowingUser_GettingCloser:
                                {
                                    /**
                                     * NORMAL_ROAMING->TrackingByCamera->FollowingUser->ApproachUser sub-sub-sub-state
                                     * Description: approach the user (get as close to the user as possible if there is no obstacles ahead)
                                     * Enter-conditions:
                                     *  - When entering NORMAL_ROAMING->TrackingByCamera->FollowingUser         >> by default
                                     *  - While in NORMAL_ROAMING->TrackingByCamera->FollowingUser->PathBlocked >> lidarIsObstacle == false is detected
                                     * Exit-conditions:
                                     *  - Higher exit-conditions of NORMAL_ROAMING->TrackingByCamera
                                     */

                                    robot->computeCameraApproach();
                                    if (robot->lidar->isObstacle == true) {
                                        robot->reproducirSonidoBloqueado();
                                        currentFollowingUser_subState = FollowingUser_ObstacleInBetween;
                                        currentState = FollowingUser_ObstacleInBetween;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case "FollowingUser_ApproachUser"
                                } // end ApproachUser

                                    // State FollowingUser_PathBlocked
                                    // Description: Obstaculo en el camino
                                    // El obstaculo puede ser una persona o un onstaculo real
                                    // Puedo rotar si la persona se mueve y retroceder
                                case FollowingUser_ObstacleInBetween:
                                {
                                    /**
                                     * NORMAL_ROAMING->TrackingByCamera->FollowingUser->PathBlocked sub-sub-sub-state
                                     * Description: approach the user (get as close to the user as possible taking into account that there's an obstacle ahead)
                                     * Enter-conditions:
                                     *  - While in NORMAL_ROAMING->TrackingByCamera->FollowingUser->ApproachUser >> lidarIsObstacle == true is detected
                                     * Exit-conditions:
                                     *  - lidarIsObstacle == false is detected >> go to NORMAL_ROAMING->TrackingByCamera->FollowingUser->ApproachUser
                                     *  - Higher exit-conditions of NORMAL_ROAMING->TrackingByCamera
                                     */

                                    // Ejecutar funcion de calculo de aproximacion con obstaculo
                                    robot->computeCameraWithObstacle();
                                    if (robot->lidar->isObstacle == false) { 
                                        robot->reproducirSonidoDesbloqueado();
                                        currentFollowingUser_subState = FollowingUser_GettingCloser;
                                        currentState = FollowingUser_GettingCloser;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case "FollowingUser_Pathblocked"
                                } // end PathLocked

                                default:
                                    throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                                    break;
                            } // end switch "currentFollowingUser_subState"
                            break; // end case "FollowingUser"
                        } // end "FollowingUser"

                        case SearchingUser:
                        {
                            /**
                             * NORMAL_ROAMING->TrackingByCamera->SearchingUser sub-sub-state
                             * Description: the user is NOT within the RGB camera's line-of-view, so the robot is searching for the user
                             * Sub-states:
                             *  - SearchingUser_Look360Around
                             *  - SearchingUser_FindEmptyHallway
                             *  - SearchingUser_TurnToEmptyHallway
                             *  - SearchingUser_TraverseEmptyHallway
                             * Enter-conditions:
                             *  - When first entering NORMAL_ROAMING->TrackingByCamera    >> cameraIsUserInView == false is detected
                             *  - While in NORMAL_ROAMING->TrackingByCamera->PersonInView >> cameraIsUserInView == false is detected
                             * Exit-conditions:
                             *  - cameraIsUserInView == true is detected >> go to NORMAL_ROAMING->TrackingByCamera->FollowingUser
                             */

                            switch (currentSearchingUser_subState) {
                                case SearchingUser_TurnToEmptyHallway:
                                {
                                    /**
                                     * NORMAL_ROAMING->TrackingByCamera->SearchingUser->Look360Around sub-sub-sub-state
                                     * Description: TODO
                                     * Enter-conditions:
                                     *  - While in NORMAL_ROAMING->TrackingByCamera->SearchingUser->FindEmptyHallway >> finished computing
                                     * Exit-conditions:
                                     *  - sensoresSumAngulo > computedAngle is detected >> go to NORMAL_ROAMING->TrackingByCamera->SearchingUser->TraverseEmptyHallway
                                     */

                                    robot->setMotores_actual(motores_LEFT);
                                    if (robot->sensores.sum_angle > robot->lidar->computedAngle) {
                                        currentSearchingUser_subState = SearchingUser_TraverseEmptyHallway;
                                        currentState = SearchingUser_TraverseEmptyHallway;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case "SearchingUser_Look360Around"
                                } // end SearchingUser_Look360Around

                                case SearchingUser_FindEmptyHallway:
                                {
                                    /**
                                     * NORMAL_ROAMING->TrackingByCamera->SearchingUser->Look360Around sub-sub-sub-state
                                     * Description: compute which direction the robot has to turn to (e.g.: find the lidar sector with highest average distance)
                                     * Enter-conditions:
                                     *  - While in NORMAL_ROAMING->TrackingByCamera->SearchingUser->Look360Around >> finished a full 360º turn
                                     * Exit-conditions:
                                     *  - [[ TODO CRITICAL ]]  >> go to NORMAL_ROAMING->TrackingByCamera->SearchingUser->Look360Around
                                     */

                                    robot->sensores.sum_angle = 0;
                                    robot->lidar->computeLidarTripPersonOutOfView();
                                    
                                    currentSearchingUser_subState = SearchingUser_TurnToEmptyHallway;
                                    currentState = SearchingUser_TurnToEmptyHallway;

                                    break; // end case "SearchingUser_FindEmptyHallway"
                                } // end SearchingUser_FindEmptyHallway

                                case SearchingUser_TraverseEmptyHallway:
                                {
                                    /**
                                     * NORMAL_ROAMING->TrackingByCamera->SearchingUser->TraverseEmptyHallway sub-sub-sub-state
                                     * Description: TODO
                                     * Enter-conditions:
                                     *  - While in NORMAL_ROAMING->TrackingByCamera->SearchingUser->Look360Around >> finished turning
                                     * Exit-conditions:
                                     *  - Finished traveling computed distance >> go to NORMAL_ROAMING->TrackingByCamera->SearchingUser->Look360Around
                                     */

                                    robot->setMotores_actual(motores_FWD);
                                    // TODO: resumir lo que se hace en este if
                                    if (robot->sensores.sum_distance > robot->lidar->computedDistance) {
                                        robot->sensores.sum_angle = 0;
                                        
                                        currentSearchingUser_subState = SearchingUser_Look360Around;
                                        currentState = SearchingUser_Look360Around;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case "SearchingUser_TraverseEmptyHallway"
                                } // end SearchingUser_TraverseEmptyHallway

                                case SearchingUser_Look360Around:
                                {
                                    /**
                                     * NORMAL_ROAMING->TrackingByCamera->SearchingUser->Look360Around sub-sub-sub-state
                                     * Description: TODO
                                     * Enter-conditions:
                                     *  - When entering NORMAL_ROAMING->TrackingByCamera->SearchingUser >> by default
                                     *  - While in NORMAL_ROAMING->TrackingByCamera->SearchingUser->TraverseEmptyHallway >> finished traveling computed distance
                                     * Exit-conditions:
                                     *  - Finished rotating 360º >> go to NORMAL_ROAMING->TrackingByCamera->SearchingUser->FindEmptyHallway
                                     */

                                    robot->setMotores_actual(motores_LEFT);
                                    if (robot->sensores.sum_angle > 360) {
                                        currentSearchingUser_subState = SearchingUser_FindEmptyHallway;
                                        currentState = SearchingUser_FindEmptyHallway;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case "SearchingUser_Look360Around"
                                } // end SearchingUser_Look360Around

                                default:
                                    throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                                    break;
                            } //end switch (SearchingUser_subState)

                            break; // end case SearchingUser
                        } //end SearchingUser

                        default:
                            throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                            break;
                    } // end switch (TrackingByCamera_subState)

                    break; // end case "TrackingByCamera"
                } // end TrackingByCamera

                case DodgingObstacle:
                {
                    /**
                     * NORMAL_ROAMING->DodgingObstacle sub-state
                     * Description: An obstacle (which has been detected by the bumpers) is being dodged
                     * Sub-states:
                     *  - NORMAL_ROAMING->DodgingObstacle->MovingBackFromObstacle
                     *  - NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm
                     * Enter-conditions:
                     *  - While in NORMAL_ROAMING->TrackingByCamera >> a bumper sensor is triggered
                     * Exit-conditions:
                     *  - subroutine 'CrashAlgorithm' finished dodging obstacle >> go to NORMAL_ROAMING->TrackingByCamera
                     *  - sensoresCliff == true is detected >> go to NORMAL_ROAMING->CliffAhead
                     */

                    if (robot->sensores.cliff == true) {
                        currentCrashAlgorithm_subState = DISABLED;
                        currentDodgingObstacle_subState = DISABLED;
                        avoidingCliff_entDef();
                        break; // Salir inmediatamente del sub-estado
                    }

                    /**
                     * NORMAL_ROAMING->DodgingObstacle sub-sub-states (third level):
                     *  - Move back
                     *  - Crash algorithm
                     */
                    switch (currentDodgingObstacle_subState) {
                        case MovingBackFromObstacle:
                        {
                            /**
                             * NORMAL_ROAMING->DodgingObstacle->MovingBackFromObstacle sub-sub-state
                             * Description: back away from the bumped obstacle
                             * Enter-conditions:
                             *  - When entering NORMAL_ROAMING->DodgingObstacle >> by default
                             *  - While in NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm >> a bumper sensor is triggered
                             * Exit-conditions:
                             *  - traveled 30cm backing away from obstacle >> go to NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm
                             */

                            robot->setMotores_actual(motores_BACK);
                            
                            if (robot->sensores.sum_distance < -30) {
                                CrashAlgorithm_entDef();
                                break; // Salir inmediatamente del sub-estado
                            }

                            break; // end case MovingBackFromObstacle
                        } // end MovingBackFromObstacle

                        case CrashAlgorithm:
                        {
                            /**
                             * NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm sub-sub-state
                             * Description: the robot is trying to dodge an obstacle (algoritmo del TFG)
                             * Sub-states:
                             *  - NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm->Dodge
                             *  - NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm->DodgeParallel
                             *  - NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm->GoForward
                             *  - NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm->GoForwardExtended
                             *  - NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm->RecoverTrajectory
                             * Enter-conditions:
                             *  - While in NORMAL_ROAMING->DodgingObstacle->MovingBackFromObstacle >> finished backing away from obstacle
                             * Exit-conditions:
                             *  - while sub-state RecoverTrajectory >> finished recovering trajectory
                             */

                            if (robot->sensores.bl == true || robot->sensores.br == true) {
                                currentCrashAlgorithm_subState = DISABLED;
                                robot->sensores.sum_distance = 0;
                                currentDodgingObstacle_subState = MovingBackFromObstacle;
                                currentState = MovingBackFromObstacle;
                                break; // Salir inmediatamente del sub-estado
                            }

                            /**
                             * "Crash Algorithm" sub-sub-sub-states (fourth level):
                             *  - Dodge
                             *  - DodgeParallel
                             *  - GoForward
                             *  - GoForwardExtended
                             *  - RecoverTrajectory
                             */
                            switch (currentCrashAlgorithm_subState) {
                                case CrashAlgorithm_Dodge:
                                {
                                    /**
                                     * NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm sub-sub-state
                                     * Description: the robot is rotating 25º to attempt a non-colliding direction
                                     * Enter-conditions:
                                     *  - When entering NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm >> by default
                                     * Exit-conditions:
                                     *  - finished turning 25º
                                     */

                                    robot->setMotores_actual(motores_LEFT);
                                    if (robot->sensores.sum_angle > 25) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_DodgeParallel;
                                        currentState = CrashAlgorithm_DodgeParallel;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case CrashAlgorithm_Dodge
                                } // end CrashAlgorithm_Dodge

                                case CrashAlgorithm_DodgeParallel:
                                {
                                    /**
                                     * NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm->DodgeParallel sub-sub-sub-state
                                     * Description: TODO
                                     * Enter-conditions:
                                     *  - While in NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm->Dodge >> finished turning 25º
                                     *  - While in NORMAL_ROAMING->DodgingObstacle->CrashAlgorithm->GoForward >> finished turning 25º
                                     * Exit-conditions:
                                     *  - finished turning 25º
                                     */

                                    robot->setMotores_actual(motores_LEFT);
                                    if (robot->sensores.lbump_front == false) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_GoForward;
                                        currentState = CrashAlgorithm_GoForward;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end CrashAlgorithm_DodgeParallel
                                } // end CrashAlgorithm_DodgeParallel

                                case CrashAlgorithm_GoForward:
                                {
                                    // State NormalOperate >> DodgingObstacle >> CrashAlgorithm >> GoForward
                                    robot->setMotores_actual(motores_FWD);
                                    if (robot->sensores.lbump_side == false) {
                                        robot->sensores.sum_distance = 0;
                                        currentCrashAlgorithm_subState = CrashAlgorithm_GoForwardExtended;
                                        currentState = CrashAlgorithm_GoForwardExtended;
                                        break; // Salir inmediatamente del sub-estado
                                    } else if (robot->sensores.lbump_front == true) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_DodgeParallel;
                                        currentState = CrashAlgorithm_DodgeParallel;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end CrashAlgorithm_GoForward
                                } // end CrashAlgorithm_GoForward

                                case CrashAlgorithm_GoForwardExtended:
                                {
                                    // State CrashAlgorithm_GoForwardExtended
                                    robot->setMotores_actual(motores_FWD);
                                    if (robot->sensores.sum_distance > 300) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_RecoverTrajectory;
                                        currentState = CrashAlgorithm_RecoverTrajectory;
                                        break; // Salir inmediatamente del sub-estado
                                    } else if (robot->sensores.lbump_front == false && robot->sensores.lbump_side == true) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_GoForward;
                                        currentState = CrashAlgorithm_GoForward;
                                        break; // Salir inmediatamente del sub-estado
                                    } else if (robot->sensores.lbump_front == true) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_DodgeParallel;
                                        currentState = CrashAlgorithm_DodgeParallel;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end CrashAlgorithm_GoForwardExtended
                                } // end CrashAlgorithm_GoForwardExtended

                                case CrashAlgorithm_RecoverTrajectory:
                                {
                                    // State CrashAlgorithm_RecoverTrajectory
                                    robot->setMotores_actual(motores_RIGHT);
                                    if (robot->sensores.sum_angle > -25 && robot->sensores.sum_angle < 25) {
                                        currentDodgingObstacle_subState = DISABLED;
                                        TrackingByCamera_entDef();
                                        break; // Salir inmediatamente del sub-estado
                                    } else if (robot->sensores.lbump_front == true) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_DodgeParallel;
                                        break; // Salir inmediatamente del sub-estado
                                        currentState = CrashAlgorithm_DodgeParallel;
                                    } else if (robot->sensores.lbump_front == false && robot->sensores.lbump_side == true) {
                                        currentCrashAlgorithm_subState = CrashAlgorithm_GoForward;
                                        currentState = CrashAlgorithm_GoForward;
                                        break; // Salir inmediatamente del sub-estado
                                    }

                                    break; // end case CrashAlgorithm_RecoverTrajectory
                                } // end CrashAlgorithm_RecoverTrajectory

                                default:
                                    throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                                    break;

                            } // end switch (CrashAlgorithm_subState)

                            break; // end case CrashAlgorithm:
                        } // end CrashAlgorithm:

                        default:
                            throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                            break;
                    } // end switch DodgingObstacle_subState

                    break; // end case DodgingObstacle
                }// end DodgingObstacle

                case AvoidingCliff:
                {
                    // State CliffAhead
                    // Description: Barranco detectado.
                    // Devolver el robot a un estado seguro.

                    /**
                     * "Cliff Ahead" sub-states:
                     *  - Rotate 180º
                     *  - Go Forward
                     */
                    switch (currentAvoidingCliff_subState) {
                        case TurnAwayFromCliff:
                        {
                            // State CliffAhead_Rotate180
                            if (robot->sensores.sum_angle > 180) {
                                currentAvoidingCliff_subState = LeaveCliffBehind;
                                currentState = LeaveCliffBehind;
                                break; // Salir inmediatamente del sub-estado
                            }

                            break; // end CliffAhead_Rotate180
                        } // end CliffAhead_Rotate180

                        case LeaveCliffBehind:
                        {
                            // State LeaveCliffBehind
                            if (robot->sensores.sum_distance > 300) {
                                currentAvoidingCliff_subState = DISABLED;
                                TrackingByCamera_entDef();
                                break; // Salir inmediatamente del sub-estado
                            }

                            break; // end LeaveCliffBehind
                        } // end LeaveCliffBehind

                        default:
                            throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                            break;

                    } // end switch (CliffAhead_subState)

                    break; // end case CliffAhead
                }

                default:
                    throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
                    break;

            } //end switch (NormalOperate_subState)

            break; // end case "NormalOperate"
        } // end NormalOperate

        default:
            throw std::logic_error("Invalid switch-case of the Robomoves state-machine");
            break;

    } // end TOP-level switch (rootState_active)

} // end void UC::statechart_process()

/**
 * TODO: documentar
 */
void RobotStateMachine::endBehavior() {

}